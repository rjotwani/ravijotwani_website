{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _TextLayerItem = require('./TextLayerItem');\n\nvar _TextLayerItem2 = _interopRequireDefault(_TextLayerItem);\n\nvar _utils = require('../shared/utils');\n\nvar _propTypes3 = require('../shared/propTypes');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar TextLayer = function (_Component) {\n  (0, _inherits3.default)(TextLayer, _Component);\n\n  function TextLayer() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    (0, _classCallCheck3.default)(this, TextLayer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = TextLayer.__proto__ || (0, _getPrototypeOf2.default)(TextLayer)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      textItems: null\n    }, _this.onGetTextSuccess = function (textContent) {\n      var textItems = null;\n\n      if (textContent) {\n        textItems = textContent.items;\n      }\n\n      (0, _utils.callIfDefined)(_this.context.onGetTextSuccess, textItems);\n\n      _this.setState({\n        textItems: textItems\n      });\n    }, _this.onGetTextError = function (error) {\n      if (error.name === 'RenderingCancelledException' || error.name === 'PromiseCancelledException') {\n        return;\n      }\n\n      (0, _utils.errorOnDev)(error.message, error);\n      (0, _utils.callIfDefined)(_this.context.onGetTextError, error);\n\n      _this.setState({\n        textItems: false\n      });\n    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);\n  }\n\n  (0, _createClass3.default)(TextLayer, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.getTextContent();\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps, nextContext) {\n      if (nextContext.page !== this.context.page) {\n        if (this.state.textItems !== null) {\n          this.setState({\n            textItems: null\n          });\n        }\n\n        this.getTextContent(nextContext);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      (0, _utils.cancelRunningTask)(this.runningTask);\n    }\n  }, {\n    key: 'getTextContent',\n    value: function getTextContent() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.context;\n      var page = context.page;\n\n      if (!page) {\n        throw new Error('Attempted to load page text content, but no page was specified.');\n      }\n\n      this.runningTask = (0, _utils.makeCancellable)(page.getTextContent());\n      return this.runningTask.promise.then(this.onGetTextSuccess).catch(this.onGetTextError);\n    }\n  }, {\n    key: 'renderTextItems',\n    value: function renderTextItems() {\n      var textItems = this.state.textItems;\n\n      if (!textItems) {\n        return null;\n      }\n\n      return textItems.map(function (textItem, itemIndex) {\n        return _react2.default.createElement(_TextLayerItem2.default // eslint-disable-next-line react/no-array-index-key\n        , (0, _extends3.default)({\n          key: itemIndex,\n          itemIndex: itemIndex\n        }, textItem));\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var viewport = this.unrotatedViewport,\n          rotate = this.rotate;\n      return _react2.default.createElement('div', {\n        className: 'react-pdf__Page__textContent',\n        style: {\n          position: 'absolute',\n          top: '50%',\n          left: '50%',\n          width: viewport.width + 'px',\n          height: viewport.height + 'px',\n          color: 'transparent',\n          transform: 'translate(-50%, -50%) rotate(' + rotate + 'deg)',\n          pointerEvents: 'none'\n        }\n      }, this.renderTextItems());\n    }\n  }, {\n    key: 'unrotatedViewport',\n    get: function get() {\n      var _context = this.context,\n          page = _context.page,\n          scale = _context.scale;\n      return page.getViewport(scale);\n    }\n    /**\n     * It might happen that the page is rotated by default. In such cases, we shouldn't rotate\n     * text content.\n     */\n\n  }, {\n    key: 'rotate',\n    get: function get() {\n      var _context2 = this.context,\n          page = _context2.page,\n          rotate = _context2.rotate;\n      return rotate - page.rotate;\n    }\n  }]);\n  return TextLayer;\n}(_react.Component);\n\nexports.default = TextLayer;\nTextLayer.contextTypes = {\n  onGetTextError: _propTypes2.default.func,\n  onGetTextSuccess: _propTypes2.default.func,\n  page: _propTypes3.isPage.isRequired,\n  rotate: _propTypes3.isRotate,\n  scale: _propTypes2.default.number\n};","map":null,"metadata":{},"sourceType":"script"}